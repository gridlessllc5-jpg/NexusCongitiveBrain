"""
Phase 3-4: Dynamic AI Civilization Features
- Quest Generation System
- Trade Network Simulation
- Territory/Conflict System
"""
import random
import uuid
from datetime import datetime
from typing import Dict, List, Optional
from dataclasses import dataclass, asdict

# Import path configuration for database locations
try:
    from core.paths import MEMORY_VAULT_DB
except ImportError:
    try:
        from paths import MEMORY_VAULT_DB
    except ImportError:
        MEMORY_VAULT_DB = "/app/npc_system/database/memory_vault.db"

# ============================================================================
# Quest Generation System
# ============================================================================

@dataclass
class Quest:
    """Dynamic quest generated by NPCs"""
    quest_id: str
    title: str
    description: str
    quest_giver: str  # NPC who created the quest
    quest_type: str  # fetch, escort, combat, trade, investigate
    objective: str
    reward: Dict  # {type: "reputation/items/currency", value: ...}
    difficulty: float  # 0.0-1.0
    status: str  # available, active, completed, failed
    prerequisites: List[str]  # Required conditions
    created_at: str

class QuestGenerator:
    """Generate dynamic quests based on NPC needs and world state"""
    
    def __init__(self):
        self.active_quests: Dict[str, Quest] = {}
        self.completed_quests: List[Quest] = []
    
    def generate_quest_from_npc(self, npc_id: str, npc_personality: Dict,
                                npc_vitals: Dict, npc_goal: str) -> Quest:
        """Generate quest based on NPC's current state"""
        
        # Select quest type based on NPC personality and needs
        quest_type = self._select_quest_type(npc_personality, npc_vitals, npc_goal)
        
        # Generate quest details
        quest_templates = {
            "fetch": self._generate_fetch_quest,
            "escort": self._generate_escort_quest,
            "combat": self._generate_combat_quest,
            "trade": self._generate_trade_quest,
            "investigate": self._generate_investigate_quest
        }
        
        generator = quest_templates.get(quest_type, self._generate_fetch_quest)
        quest_data = generator(npc_id, npc_personality)
        
        quest = Quest(
            quest_id=str(uuid.uuid4())[:8],
            title=quest_data["title"],
            description=quest_data["description"],
            quest_giver=npc_id,
            quest_type=quest_type,
            objective=quest_data["objective"],
            reward=quest_data["reward"],
            difficulty=quest_data["difficulty"],
            status="available",
            prerequisites=quest_data.get("prerequisites", []),
            created_at=datetime.now().isoformat()
        )
        
        self.active_quests[quest.quest_id] = quest
        return quest
    
    def _select_quest_type(self, personality: Dict, vitals: Dict, goal: str) -> str:
        """Select quest type based on NPC state"""
        
        # High hunger = fetch quest (food)
        if vitals.get("hunger", 0) > 0.7:
            return "fetch"
        
        # High opportunism = trade quest
        if personality.get("opportunism", 0) > 0.7:
            return "trade"
        
        # High aggression = combat quest
        if personality.get("aggression", 0) > 0.7:
            return "combat"
        
        # High curiosity = investigate quest
        if personality.get("curiosity", 0) > 0.7:
            return "investigate"
        
        # Default based on goal
        goal_map = {
            "secure_area": "combat",
            "maximize_profit": "trade",
            "gather_knowledge": "investigate",
            "survive": "fetch"
        }
        
        return goal_map.get(goal, random.choice(["fetch", "escort", "trade"]))
    
    def _generate_fetch_quest(self, npc_id: str, personality: Dict) -> Dict:
        """Generate a fetch/gather quest"""
        items = ["medical supplies", "food rations", "clean water", "ammunition", "tools"]
        item = random.choice(items)
        locations = ["abandoned warehouse", "old settlement", "supply depot", "ruins"]
        location = random.choice(locations)
        
        return {
            "title": f"Gather {item.title()}",
            "description": f"{npc_id} needs {item} urgently. They've heard rumors of supplies at {location}.",
            "objective": f"Retrieve {item} from {location} and bring them back",
            "reward": {"type": "reputation", "value": 15, "items": ["basic_supplies"]},
            "difficulty": 0.4,
            "prerequisites": []
        }
    
    def _generate_combat_quest(self, npc_id: str, personality: Dict) -> Dict:
        """Generate a combat quest"""
        threats = ["raiders", "hostile scavengers", "rogue mercenaries", "infected"]
        threat = random.choice(threats)
        locations = ["east perimeter", "supply route", "abandoned district", "outer zones"]
        location = random.choice(locations)
        
        return {
            "title": f"Clear {threat.title()} Threat",
            "description": f"{npc_id} reports {threat} activity near {location}. The area needs to be secured.",
            "objective": f"Eliminate {threat} threat at {location}",
            "reward": {"type": "reputation", "value": 25, "items": ["combat_gear"]},
            "difficulty": 0.7,
            "prerequisites": ["combat_ready"]
        }
    
    def _generate_trade_quest(self, npc_id: str, personality: Dict) -> Dict:
        """Generate a trade quest"""
        goods = ["ammunition for medical supplies", "tools for food", "information for currency"]
        trade = random.choice(goods)
        
        return {
            "title": "Trade Opportunity",
            "description": f"{npc_id} has a trade offer: {trade}. Mutually beneficial deal.",
            "objective": f"Complete trade: {trade}",
            "reward": {"type": "items", "value": 0, "items": ["traded_goods"]},
            "difficulty": 0.3,
            "prerequisites": []
        }
    
    def _generate_investigate_quest(self, npc_id: str, personality: Dict) -> Dict:
        """Generate an investigation quest"""
        mysteries = [
            "strange signals from old radio tower",
            "missing supply convoy",
            "unusual activity in restricted zone",
            "rumors of hidden cache"
        ]
        mystery = random.choice(mysteries)
        
        return {
            "title": "Investigate Mystery",
            "description": f"{npc_id} needs someone to look into {mystery}.",
            "objective": f"Investigate and report findings about {mystery}",
            "reward": {"type": "reputation", "value": 20, "items": ["information"]},
            "difficulty": 0.5,
            "prerequisites": []
        }
    
    def _generate_escort_quest(self, npc_id: str, personality: Dict) -> Dict:
        """Generate an escort quest"""
        targets = ["supply convoy", "civilian refugees", "important cargo", "wounded scout"]
        target = random.choice(targets)
        destinations = ["safe zone", "medical facility", "allied outpost", "secure location"]
        destination = random.choice(destinations)
        
        return {
            "title": f"Escort {target.title()}",
            "description": f"{npc_id} needs someone to escort {target} to {destination}.",
            "objective": f"Safely escort {target} to {destination}",
            "reward": {"type": "reputation", "value": 30, "items": ["escort_bonus"]},
            "difficulty": 0.6,
            "prerequisites": []
        }
    
    def get_available_quests(self) -> List[Quest]:
        """Get all available quests"""
        return [q for q in self.active_quests.values() if q.status == "available"]
    
    def complete_quest(self, quest_id: str) -> Optional[Quest]:
        """Mark quest as completed"""
        if quest_id in self.active_quests:
            quest = self.active_quests[quest_id]
            quest.status = "completed"
            self.completed_quests.append(quest)
            del self.active_quests[quest_id]
            return quest
        return None


# ============================================================================
# Trade Network System
# ============================================================================

@dataclass
class TradeOffer:
    """Trade offer between NPCs or with player"""
    offer_id: str
    from_npc: str
    offering: Dict  # {item: quantity}
    requesting: Dict  # {item: quantity}
    status: str  # open, accepted, completed, expired
    created_at: str

class TradeNetwork:
    """Simulate dynamic trade between NPCs"""
    
    def __init__(self):
        self.active_offers: Dict[str, TradeOffer] = {}
        self.trade_history: List[Dict] = []
        self.npc_inventories: Dict[str, Dict] = {}
    
    def create_trade_offer(self, npc_id: str, offering: Dict, requesting: Dict) -> TradeOffer:
        """NPC creates a trade offer"""
        offer = TradeOffer(
            offer_id=str(uuid.uuid4())[:8],
            from_npc=npc_id,
            offering=offering,
            requesting=requesting,
            status="open",
            created_at=datetime.now().isoformat()
        )
        
        self.active_offers[offer.offer_id] = offer
        return offer
    
    def auto_trade_between_npcs(self, npc1_id: str, npc2_id: str, 
                                npc1_personality: Dict, npc2_personality: Dict) -> Optional[Dict]:
        """Simulate autonomous trade between two NPCs"""
        
        # Check if trade is likely based on personalities
        if (npc1_personality.get("opportunism", 0) < 0.4 or 
            npc2_personality.get("opportunism", 0) < 0.4):
            return None  # Not interested in trading
        
        # Generate random trade
        goods = ["food", "water", "ammo", "tools", "medicine"]
        trade_result = {
            "from": npc1_id,
            "to": npc2_id,
            "npc1_gave": {random.choice(goods): random.randint(1, 5)},
            "npc2_gave": {random.choice(goods): random.randint(1, 5)},
            "success": True,
            "timestamp": datetime.now().isoformat()
        }
        
        self.trade_history.append(trade_result)
        return trade_result
    
    def get_market_activity(self) -> Dict:
        """Get current market activity summary"""
        return {
            "active_offers": len(self.active_offers),
            "recent_trades": len([t for t in self.trade_history[-20:]]),
            "top_traders": self._get_top_traders()
        }
    
    def _get_top_traders(self) -> List[str]:
        """Get NPCs with most trade activity"""
        trader_counts = {}
        for trade in self.trade_history[-50:]:
            trader_counts[trade["from"]] = trader_counts.get(trade["from"], 0) + 1
            trader_counts[trade["to"]] = trader_counts.get(trade["to"], 0) + 1
        
        return sorted(trader_counts.keys(), key=lambda x: trader_counts[x], reverse=True)[:5]


# ============================================================================
# Territory & Conflict System
# ============================================================================

@dataclass
class Territory:
    """Territory controlled by a faction"""
    territory_id: str
    name: str
    controlling_faction: str
    resource_value: float  # 0.0-1.0
    strategic_value: float  # 0.0-1.0
    contested: bool
    garrison_strength: float  # 0.0-1.0

class TerritorySystem:
    """Manage territory control and faction conflicts"""
    
    def __init__(self):
        self.territories: Dict[str, Territory] = {}
        self.conflict_history: List[Dict] = []
        self._initialize_territories()
    
    def _initialize_territories(self):
        """Create initial territories"""
        initial_territories = [
            {"name": "Porto Cobre Gates", "faction": "guards", "resource": 0.7, "strategic": 0.9},
            {"name": "Market District", "faction": "traders", "resource": 0.8, "strategic": 0.6},
            {"name": "Residential Zone", "faction": "citizens", "resource": 0.5, "strategic": 0.4},
            {"name": "Outer Perimeter", "faction": "guards", "resource": 0.3, "strategic": 0.8},
            {"name": "Trade Route", "faction": "traders", "resource": 0.6, "strategic": 0.7}
        ]
        
        for terr in initial_territories:
            territory = Territory(
                territory_id=terr["name"].lower().replace(" ", "_"),
                name=terr["name"],
                controlling_faction=terr["faction"],
                resource_value=terr["resource"],
                strategic_value=terr["strategic"],
                contested=False,
                garrison_strength=random.uniform(0.5, 0.8)
            )
            self.territories[territory.territory_id] = territory
    
    def simulate_faction_tension(self, faction1: str, faction2: str, 
                                 tension_level: float) -> Optional[Dict]:
        """Simulate tension between factions over territory"""
        if tension_level < 0.6:
            return None  # Not enough tension for conflict
        
        # Find contested territories
        contested = []
        for terr in self.territories.values():
            if (terr.controlling_faction == faction1 or 
                terr.controlling_faction == faction2):
                contested.append(terr)
        
        if not contested:
            return None
        
        target = random.choice(contested)
        target.contested = True
        
        conflict = {
            "type": "territorial_dispute",
            "territory": target.name,
            "factions": [faction1, faction2],
            "tension_level": tension_level,
            "timestamp": datetime.now().isoformat(),
            "status": "ongoing"
        }
        
        self.conflict_history.append(conflict)
        return conflict
    
    def get_faction_territories(self, faction: str) -> List[Territory]:
        """Get all territories controlled by a faction"""
        return [t for t in self.territories.values() if t.controlling_faction == faction]
    
    def get_territorial_overview(self) -> Dict:
        """Get overview of territorial control"""
        overview = {}
        for faction in ["guards", "traders", "citizens", "outcasts"]:
            territories = self.get_faction_territories(faction)
            overview[faction] = {
                "controlled_territories": len(territories),
                "total_resources": sum(t.resource_value for t in territories),
                "contested_count": sum(1 for t in territories if t.contested)
            }
        return overview


# ============================================================================
# Faction System - Relations, Wars, Alliances
# ============================================================================

@dataclass
class FactionRelation:
    """Relationship between two factions"""
    faction1: str
    faction2: str
    relation_score: float  # -1.0 (war) to 1.0 (alliance)
    relation_type: str  # war, hostile, neutral, friendly, allied
    history: List[Dict]


class FactionSystem:
    """Manage faction relationships and dynamics"""
    
    FACTIONS = {
        "guards": {
            "name": "City Guards",
            "description": "Protectors of Porto Cobre, enforcers of law",
            "values": ["order", "duty", "protection"],
            "color": "#4a90d9"
        },
        "traders": {
            "name": "Merchant Guild",
            "description": "Traders and businesspeople who control commerce",
            "values": ["profit", "negotiation", "connections"],
            "color": "#d9a84a"
        },
        "citizens": {
            "name": "Citizens",
            "description": "Common folk of Porto Cobre",
            "values": ["peace", "community", "survival"],
            "color": "#7dd94a"
        },
        "outcasts": {
            "name": "Outcasts",
            "description": "Those rejected by society - criminals, exiles, rebels",
            "values": ["freedom", "revenge", "survival"],
            "color": "#d94a4a"
        }
    }
    
    def __init__(self, db_path: str = None):
        import sqlite3
        self.db_path = db_path or MEMORY_VAULT_DB
        self.relations: Dict[str, FactionRelation] = {}
        self._initialize_relations()
        self._initialize_database()
    
    def _initialize_database(self):
        """Create faction tables in database"""
        import sqlite3
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Player faction reputation
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS player_faction_reputation (
                player_id TEXT,
                faction TEXT,
                reputation REAL DEFAULT 0.0,
                total_interactions INTEGER DEFAULT 0,
                PRIMARY KEY (player_id, faction)
            )
        """)
        
        # Faction events history
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS faction_events (
                event_id TEXT PRIMARY KEY,
                event_type TEXT,
                factions_involved TEXT,
                description TEXT,
                impact TEXT,
                timestamp TEXT
            )
        """)
        
        conn.commit()
        conn.close()
        print("âœ“ Faction system database initialized")
    
    def _initialize_relations(self):
        """Set initial faction relationships"""
        # Default relations: Guards vs Outcasts (hostile), Guards & Traders (friendly), etc.
        initial_relations = [
            ("guards", "traders", 0.6, "friendly"),     # Guards protect trade
            ("guards", "citizens", 0.4, "friendly"),    # Guards protect citizens
            ("guards", "outcasts", -0.8, "hostile"),    # Guards hunt outcasts
            ("traders", "citizens", 0.3, "neutral"),    # Business relationship
            ("traders", "outcasts", -0.3, "neutral"),   # Illegal trade sometimes
            ("citizens", "outcasts", -0.4, "hostile"),  # Fear and distrust
        ]
        
        for f1, f2, score, rel_type in initial_relations:
            key = self._relation_key(f1, f2)
            self.relations[key] = FactionRelation(
                faction1=f1,
                faction2=f2,
                relation_score=score,
                relation_type=rel_type,
                history=[]
            )
    
    def _relation_key(self, faction1: str, faction2: str) -> str:
        """Create consistent key for faction pair"""
        return f"{min(faction1, faction2)}_{max(faction1, faction2)}"
    
    def get_relation(self, faction1: str, faction2: str) -> FactionRelation:
        """Get relationship between two factions"""
        key = self._relation_key(faction1, faction2)
        if key in self.relations:
            return self.relations[key]
        
        # Create neutral relation if not exists
        self.relations[key] = FactionRelation(
            faction1=faction1,
            faction2=faction2,
            relation_score=0.0,
            relation_type="neutral",
            history=[]
        )
        return self.relations[key]
    
    def update_relation(self, faction1: str, faction2: str, change: float, reason: str) -> FactionRelation:
        """Update relationship between factions"""
        relation = self.get_relation(faction1, faction2)
        
        old_score = relation.relation_score
        relation.relation_score = max(-1.0, min(1.0, relation.relation_score + change))
        
        # Update relation type based on score
        if relation.relation_score <= -0.7:
            relation.relation_type = "war"
        elif relation.relation_score <= -0.3:
            relation.relation_type = "hostile"
        elif relation.relation_score < 0.3:
            relation.relation_type = "neutral"
        elif relation.relation_score < 0.7:
            relation.relation_type = "friendly"
        else:
            relation.relation_type = "allied"
        
        # Log history
        relation.history.append({
            "change": change,
            "reason": reason,
            "old_score": old_score,
            "new_score": relation.relation_score,
            "timestamp": datetime.now().isoformat()
        })
        
        # Keep history limited
        if len(relation.history) > 20:
            relation.history = relation.history[-20:]
        
        return relation
    
    def get_player_faction_reputation(self, player_id: str) -> Dict[str, float]:
        """Get player's reputation with all factions"""
        import sqlite3
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT faction, reputation FROM player_faction_reputation
            WHERE player_id = ?
        """, (player_id,))
        
        reps = {row[0]: row[1] for row in cursor.fetchall()}
        conn.close()
        
        # Fill in missing factions with 0
        for faction in self.FACTIONS.keys():
            if faction not in reps:
                reps[faction] = 0.0
        
        return reps
    
    def update_player_faction_reputation(self, player_id: str, faction: str, change: float) -> float:
        """Update player's reputation with a faction"""
        import sqlite3
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Get current reputation
        cursor.execute("""
            SELECT reputation FROM player_faction_reputation
            WHERE player_id = ? AND faction = ?
        """, (player_id, faction))
        
        row = cursor.fetchone()
        current = row[0] if row else 0.0
        new_rep = max(-1.0, min(1.0, current + change))
        
        # Upsert
        cursor.execute("""
            INSERT INTO player_faction_reputation (player_id, faction, reputation, total_interactions)
            VALUES (?, ?, ?, 1)
            ON CONFLICT(player_id, faction) DO UPDATE SET
                reputation = ?,
                total_interactions = total_interactions + 1
        """, (player_id, faction, new_rep, new_rep))
        
        conn.commit()
        conn.close()
        
        # Ripple effect: Helping one faction may hurt relations with enemies
        self._apply_faction_ripple(player_id, faction, change)
        
        return new_rep
    
    def _apply_faction_ripple(self, player_id: str, faction: str, change: float):
        """Apply ripple effects to enemy/allied factions"""
        import sqlite3
        
        for key, relation in self.relations.items():
            if faction in [relation.faction1, relation.faction2]:
                other_faction = relation.faction2 if relation.faction1 == faction else relation.faction1
                
                # If player helps faction, enemy factions lose trust
                if relation.relation_type in ["hostile", "war"]:
                    ripple = -change * 0.3  # 30% negative ripple
                    conn = sqlite3.connect(self.db_path)
                    cursor = conn.cursor()
                    
                    cursor.execute("""
                        INSERT INTO player_faction_reputation (player_id, faction, reputation, total_interactions)
                        VALUES (?, ?, ?, 0)
                        ON CONFLICT(player_id, faction) DO UPDATE SET
                            reputation = MAX(-1.0, MIN(1.0, reputation + ?))
                    """, (player_id, other_faction, ripple, ripple))
                    
                    conn.commit()
                    conn.close()
    
    def get_faction_status(self, faction: str) -> Dict:
        """Get comprehensive faction status"""
        if faction not in self.FACTIONS:
            return {"error": "Unknown faction"}
        
        info = self.FACTIONS[faction].copy()
        
        # Get relations with other factions
        relations = {}
        for other in self.FACTIONS.keys():
            if other != faction:
                rel = self.get_relation(faction, other)
                relations[other] = {
                    "score": rel.relation_score,
                    "type": rel.relation_type
                }
        
        info["relations"] = relations
        return info
    
    def get_all_factions_status(self) -> Dict:
        """Get status of all factions"""
        return {
            faction: self.get_faction_status(faction)
            for faction in self.FACTIONS.keys()
        }
    
    def trigger_faction_event(self, event_type: str, factions: List[str], description: str) -> Dict:
        """Trigger a faction-related event"""
        import sqlite3
        import json
        
        event = {
            "event_id": str(uuid.uuid4())[:12],
            "event_type": event_type,
            "factions_involved": factions,
            "description": description,
            "timestamp": datetime.now().isoformat()
        }
        
        # Apply effects based on event type
        impact = {}
        if event_type == "skirmish":
            # Small conflict, slight reputation hit between factions
            self.update_relation(factions[0], factions[1], -0.1, description)
            impact["relation_change"] = -0.1
        elif event_type == "trade_deal":
            # Trade improves relations
            self.update_relation(factions[0], factions[1], 0.1, description)
            impact["relation_change"] = 0.1
        elif event_type == "betrayal":
            # Major relation hit
            self.update_relation(factions[0], factions[1], -0.3, description)
            impact["relation_change"] = -0.3
        elif event_type == "alliance_formed":
            # Major relation boost
            self.update_relation(factions[0], factions[1], 0.4, description)
            impact["relation_change"] = 0.4
        
        event["impact"] = impact
        
        # Store in database
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO faction_events (event_id, event_type, factions_involved, description, impact, timestamp)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (event["event_id"], event_type, json.dumps(factions), description, json.dumps(impact), event["timestamp"]))
        conn.commit()
        conn.close()
        
        return event
    
    def get_recent_events(self, limit: int = 10) -> List[Dict]:
        """Get recent faction events"""
        import sqlite3
        import json
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("""
            SELECT event_id, event_type, factions_involved, description, impact, timestamp
            FROM faction_events
            ORDER BY timestamp DESC
            LIMIT ?
        """, (limit,))
        
        events = []
        for row in cursor.fetchall():
            events.append({
                "event_id": row[0],
                "event_type": row[1],
                "factions_involved": json.loads(row[2]) if row[2] else [],
                "description": row[3],
                "impact": json.loads(row[4]) if row[4] else {},
                "timestamp": row[5]
            })
        
        conn.close()
        return events


# Global instances
quest_generator = QuestGenerator()
trade_network = TradeNetwork()
territory_system = TerritorySystem()
faction_system = FactionSystem()
